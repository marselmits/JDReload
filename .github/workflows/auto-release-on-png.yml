name: Auto Release on PNG push

on:
  push:
    branches: [ main ]                 # ggf. deinen Default-Branch anpassen
    paths:
      - 'JDReload/media/png/**'        # nur triggern, wenn PNGs geändert wurden
  workflow_dispatch: {}                # manuell startbar

jobs:
  build-and-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write                  # für Tag/Release + Push
    env:
      # --- Versionierungsmodus ---
      AUTO_VERSION_MODE: semver        # semver | timestamp
      VERSION_PREFIX: "1.0"            # nur für timestamp-Modus (z.B. "1.0")

      # --- Wago Secrets/Variablen ---
      WAGO_API_KEY: ${{ secrets.WAGO_API_KEY }}
      WAGO_PROJECT_ID: ${{ vars.WAGO_PROJECT_ID }}
      WAGO_RETAIL_PATCH: ${{ vars.WAGO_RETAIL_PATCH }}

    steps:
      - name: Checkout (with tags)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install deps
        run: |
          pip install pillow
          sudo apt-get update
          sudo apt-get install -y zip jq

      # 1) PNG -> TGA (512x512 transparent, zentriert)
      - name: Convert PNG -> TGA
        run: |
          python - << 'PY'
          from pathlib import Path
          from PIL import Image
          png_root = Path("JDReload/media/png")
          out_root = Path("JDReload/media"); out_root.mkdir(parents=True, exist_ok=True)
          def fit(img, size=(512,512)):
              cw,ch=size; img=img.convert("RGBA")
              iw,ih=img.size; s=min(cw/iw, ch/ih)
              nw=max(1,int(iw*s)); nh=max(1,int(ih*s))
              r=img.resize((nw,nh), Image.LANCZOS)
              c=Image.new("RGBA",(cw,ch),(0,0,0,0))
              c.paste(r, ((cw-nw)//2,(ch-nh)//2), r)
              return c
          for p in png_root.rglob("*.png"):
              out = fit(Image.open(p),(512,512))
              out.save(out_root/(p.stem+".tga"), format="TGA", compress=False)
              print("[OK]", p)
          PY

      # 2) Lua-Liste erzeugen
      - name: Generate JDReload_Textures.lua
        run: |
          python - << 'PY'
          from pathlib import Path
          media = Path("JDReload/media")
          tgas = sorted(media.glob("*.tga"))
          lua = Path("JDReload/JDReload_Textures.lua")
          def wow(p): return ("Interface\\AddOns\\JDReload\\media\\"+p.name).replace("\\","\\\\")
          lines = [
            "-- !!! AUTO-GENERIERT. NICHT MANUELL EDITIEREN !!!",
            "JDReloadTextures = JDReloadTextures or {}",
            "JDReloadTextures.CUSTOM_TEXTURES = {",
          ] + [f'  "{wow(p)}",' for p in tgas] + ["}"]
          lua.write_text("\n".join(lines), encoding="utf-8")
          print("wrote", lua, "entries:", len(tgas))
          PY

      # 3) Debug
      - name: Show tree and counts
        run: |
          echo "== TREE ==" && ls -R
          echo "== COUNTS =="
          echo "PNGs:" $(find JDReload/media/png -type f -iname '*.png' | wc -l || true)
          echo "TGAs:" $(find JDReload/media -maxdepth 1 -type f -iname '*.tga' | wc -l || true)

      # 4) Generierte Dateien committen (triggert NICHT erneut, da Trigger nur auf png/** hört)
      - name: Commit & push generated files
        run: |
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add JDReload/media JDReload/JDReload_Textures.lua || true
          git diff --cached --quiet || git commit -m "chore(media): auto-convert PNG->TGA and regen list [ci skip]"
          git push || true

      # 5) TOC-Version automatisch setzen/erhöhen und committen
      - name: Auto-bump TOC version
        id: bumpver
        run: |
          set -euo pipefail
          MODE="${AUTO_VERSION_MODE}"
          TOC="JDReload/JDReload.toc"

          # Aktuelle Version lesen (falls vorhanden)
          CUR=$(sed -n 's/^##[[:space:]]*Version:[[:space:]]*\(.*\)$/\1/p' "$TOC" | head -n1 | tr -d '\r' || true)
          echo "Current TOC Version: ${CUR:-<none>}"

          if [ "$MODE" = "timestamp" ]; then
            TS=$(date -u +'%Y%m%d%H%M%S')
            PRE="${VERSION_PREFIX:-1.0}"
            NEW="${PRE}.${TS}"
          else
            # semver patch bump
            if echo "${CUR:-}" | grep -Eq '^[0-9]+\.[0-9]+\.[0-9]+$'; then
              MAJ=$(echo "$CUR" | cut -d. -f1)
              MIN=$(echo "$CUR" | cut -d. -f2)
              PAT=$(echo "$CUR" | cut -d. -f3)
              NEW="${MAJ}.${MIN}.$((PAT+1))"
            elif echo "${CUR:-}" | grep -Eq '^[0-9]+\.[0-9]+$'; then
              # Wenn nur X.Y vorhanden ist, starte bei X.Y.0
              NEW="${CUR}.0"
            else
              # Fallback wenn nichts gefunden: starte bei 1.0.0
              NEW="1.0.0"
            fi
          fi

          echo "New TOC Version: $NEW"

          # Zeile ersetzen oder hinzufügen
          if grep -qE '^##[[:space:]]*Version:' "$TOC"; then
            sed -i.bak -E "s/^##[[:space:]]*Version:.*$/## Version: ${NEW}/" "$TOC"
          else
            printf "\n## Version: %s\n" "$NEW" >> "$TOC"
          fi
          rm -f "$TOC.bak"

          echo "VER=$NEW" >> $GITHUB_ENV

          # Commit & Push der Versionsänderung
          git add "$TOC"
          git diff --cached --quiet || git commit -m "chore(version): bump to ${NEW} [ci skip]"
          git push || true

      # 6) Tag aus der neuen TOC-Version erstellen (oder überspringen, wenn existiert)
      - name: Create tag from TOC version
        id: tag
        run: |
          set -euo pipefail
          TAG="v${VER}"
          echo "Using TAG=$TAG"
          echo "TAG=$TAG" >> $GITHUB_ENV

          if git rev-parse -q --verify "refs/tags/$TAG" >/dev/null; then
            echo "Tag $TAG already exists; skipping tag creation"
          else
            git tag -a "$TAG" -m "Auto release $TAG"
            git push origin "$TAG"
          fi

      # 7) ZIP bauen (PNG-Quellen ausschließen)
      - name: Create ZIP
        run: |
          ZIP="JDReload-${TAG}.zip"
          zip -r "$ZIP" JDReload -x "JDReload/media/png/*" "**/.DS_Store" "**/Thumbs.db"
          ls -lh "$ZIP"
          echo "ZIP=$ZIP" >> $GITHUB_ENV

      # 8) GitHub Release veröffentlichen
      - name: Publish GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ env.TAG }}
          name: JDReload ${{ env.TAG }}
          draft: false
          prerelease: false
          files: |
            ${{ env.ZIP }}

      # 9) Wago Upload (nur wenn Secrets/Vars gesetzt)
      - name: Upload to Wago
        if: ${{ env.WAGO_API_KEY != '' && env.WAGO_PROJECT_ID != '' }}
        run: |
          # Stabilität aus dem Tag ableiten (alpha/beta/stable)
          if [[ "${TAG,,}" == *"alpha"* ]]; then STABILITY="alpha";
          elif [[ "${TAG,,}" == *"beta"* ]]; then STABILITY="beta";
          else STABILITY="stable"; fi

          CHANGELOG="# Changelog\n\nAutomatischer Build ${TAG}."

          METADATA=$(jq -nc \
            --arg label "$TAG" \
            --arg stability "$STABILITY" \
            --arg changelog "$CHANGELOG" \
            --arg retail "$WAGO_RETAIL_PATCH" \
            '{label:$label, stability:$stability, changelog:$changelog, supported_retail_patch:$retail}')

          echo "Metadata: $METADATA"

          curl -f -X POST \
            -H "authorization: Bearer ${WAGO_API_KEY}" \
            -H "accept: application/json" \
            -F "metadata=${METADATA}" \
            -F "file=@${ZIP}" \
            "https://addons.wago.io/api/projects/${WAGO_PROJECT_ID}/version"
